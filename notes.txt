/**
 * java入口程序规定的方法必须是静态方法，方法名必须为main,括号内的参数必须是String数组。
 * 变量分为两种：基本类型的变量和引用类型的变量。
 * 基本数据类型：
 *  整数类型：  byte(1个byte有8个bit), short, int, long
 *  浮点数类型：float, double
 *  字符类型：  char
 *  布尔类型：  boolean
 * 引用类型：
 *  String, 对象, 数组
 * 
 */

/**
 * 一个(byte)字节就是一个8位二进制数，即8个bit,long和double需要8个字节。
 * 同一个数的不同进制的表示是完全相同的。
 * 对于float类型，需要加上f后缀。
 * 使用var定义变量，仅仅是少写了变量类型而已。
 * /


====================== 引用类型 ======================
    1.引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。

    ============== 字符串 ==============
    java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变，变的是变量的“指向”。
    执行String s = "hello";时，JVM虚拟机先创建字符串"hello"，然后，把字符串变量s指向它：
    紧接着，执行s = "world";时，JVM虚拟机先创建字符串"world"，然后，把字符串变量s指向它：
    原来的字符串"hello"还在，只是我们无法通过变量s访问它而已。因此，字符串的不可变是指字符串内容不可变。



============== 浮点数运算 ==============
因为浮点数常常无法精确表示，因此，浮点数运算会产生误差。
如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型
整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：NaN、Infinity、Infinity（实际中很少碰到）
可以将浮点数强制转型为整数。在转型时，浮点数的小数部分回被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。
如果要进行四舍五入，可以对浮点数加上0.5再强制转型。

============== 数组 ==============
数组是引用类型。
直接打印数组，得到的是数组在JVM中的引用地址。
Arrays.toString()，可以快速打印数组内容。


============== 构造方法 ==============
认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。

============== 重写 ==============
重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。
子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
构造方法不能被重写。
如果不能继承一个类，则不能重写该类的方法。

============== 继承 ==============
java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。
java之中只允许多层继承，不允许多重继承。
在继承关系中，如果要实例化子类对象，会默认先调用父类构造。调用父类构造的方法体执行，而后再实例化子类对象。
protected关键字可以把字段和方法的访问权控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问。如果父类没有无参构造函数，则子类必须通过super()调用指定参数的构造方法。
子类自动获得了父类的所有字段，严禁定义与父类重名的字段。
术语：父类：super class|parent class|base class
     子类：subclass|extended class
向下转型和向上转型

============== 继承 - 重写 ==============
在子类中创建了一个与父类中名称相同、返回值类型相同、参数列表的方法相同，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写（override）
修饰符：范围可以扩大但不能缩小：public>Protected>Default。
抛出的异常：范围，可以被缩小，但不能扩大。
声明为 final 的方法不能被重写。
子类和父类在同一个包中时，子类可以重写父类除了声明为 private 和 final 方法的其他方法。
子类和父类不在同一个包中时，子类只能重写父类的声明为 public 和 protected 的非 final 方法。
加上@Override可以让编译器帮助检查是否进行了正确的覆写。（Override不是必须的）

============== 多态 ==============
定义：同一个接口，使用不同的实例而执行不同操作。
子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法，要想调用父类中被重写的方法，则必须使用关键字 super。
多态存在的三个必要条件：
    1.继承
    2.重写
    3.父类引用指向子类对象：Parent p = new Child();

============== 抽象类 ==============
抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。
继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。

