/**
 * java入口程序规定的方法必须是静态方法，方法名必须为main,括号内的参数必须是String数组。
 * 变量分为两种：基本类型的变量和引用类型的变量。
 * 基本数据类型：
 *  整数类型：  byte(1个byte有8个bit), short, int, long
 *  浮点数类型：float, double
 *  字符类型：  char
 *  布尔类型：  boolean
 * 引用类型：
 *  String, 对象, 数组
 * 
 */

/**
 * 一个(byte)字节就是一个8位二进制数，即8个bit,long和double需要8个字节。
 * 同一个数的不同进制的表示是完全相同的。
 * 对于float类型，需要加上f后缀。
 * 使用var定义变量，仅仅是少写了变量类型而已。
 * /


====================== 引用类型 ======================
    1.引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。

    ============== 字符串 ==============
    java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变，变的是变量的“指向”。
    执行String s = "hello";时，JVM虚拟机先创建字符串"hello"，然后，把字符串变量s指向它：
    紧接着，执行s = "world";时，JVM虚拟机先创建字符串"world"，然后，把字符串变量s指向它：
    原来的字符串"hello"还在，只是我们无法通过变量s访问它而已。因此，字符串的不可变是指字符串内容不可变。



============== 浮点数运算 ==============
因为浮点数常常无法精确表示，因此，浮点数运算会产生误差。
如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型
整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：NaN、Infinity、Infinity（实际中很少碰到）
可以将浮点数强制转型为整数。在转型时，浮点数的小数部分回被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。
如果要进行四舍五入，可以对浮点数加上0.5再强制转型。

============== 数组 ==============
数组是引用类型。
直接打印数组，得到的是数组在JVM中的引用地址。
Arrays.toString()，可以快速打印数组内容。


============== 构造方法 ==============
认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。

============== 重写 ==============
重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。
子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
构造方法不能被重写。
如果不能继承一个类，则不能重写该类的方法。

============== 继承 ==============
java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。
protected关键字可以把字段和方法的访问权控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问。
子类自动获得了父类的所有字段，严禁定义与父类重名的字段。
术语：父类：super class|parent class|base class
     子类：subclass|extended class
